<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTRPG WebSocket Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        .test-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .test-overlay h2 {
            color: #4ade80;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .status-line {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connecting { background: #fbbf24; }
        .status-connected { background: #10b981; }
        .status-disconnected { background: #ef4444; }
        
        .test-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .test-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .test-btn:hover:not(:disabled) {
            background: #2563eb;
        }
        
        .test-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }
        
        .test-input {
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: white;
            font-size: 12px;
            margin-bottom: 8px;
        }
        
        .log-mini {
            background: #111;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin-bottom: 4px;
            opacity: 0.8;
        }
        
        .log-sent { color: #3b82f6; }
        .log-received { color: #10b981; }
        .log-error { color: #ef4444; }
        .log-info { color: #fbbf24; }
        
        .game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            border: none;
            outline: none;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #10b981;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
        }
        
        .toggle-btn {
            position: fixed;
            top: 20px;
            right: 380px;
            background: rgba(59, 130, 246, 0.8);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Full-screen canvas for future game integration -->
    <canvas id="gameCanvas" class="game-canvas" tabindex="0"></canvas>
    
    <!-- Canvas status overlay -->
    <div class="canvas-overlay">
        <div>TTRPG Client Ready</div>
        <div id="canvasStatus">Canvas: Initialized</div>
    </div>
    
    <!-- Toggle button for test panel -->
    <button class="toggle-btn" onclick="toggleTestPanel()" id="toggleBtn">Hide Panel</button>
    
    <!-- Floating test panel -->
    <div class="test-overlay" id="testPanel">
        <h2>WebSocket Test</h2>
        
        <div class="status-line">
            <span class="status-dot status-disconnected" id="statusDot"></span>
            <span id="statusText">Disconnected</span>
        </div>
        
        <div class="test-controls">
            <button class="test-btn" onclick="connectWS()" id="connectBtn">Connect</button>
            <button class="test-btn" onclick="disconnectWS()" id="disconnectBtn" disabled>Disconnect</button>
            <button class="test-btn" onclick="sendPing()" id="pingBtn" disabled>Ping</button>
            <button class="test-btn" onclick="requestTable()" id="tableBtn" disabled>Table Data</button>
        </div>
        
        <input type="text" class="test-input" id="spriteInput" placeholder="Sprite name" value="Test Sprite">
        <div class="test-controls">
            <button class="test-btn" onclick="createSprite()" id="spriteBtn" disabled>Add Sprite</button>
            <button class="test-btn" onclick="createTestSprites()" id="testBtn" disabled>Test Sprites</button>
        </div>
        
        <button class="test-btn" onclick="clearLog()" style="width: 100%; margin-bottom: 10px;">Clear Log</button>
        
        <div class="log-mini" id="logArea">
            <div class="log-entry log-info">[Ready] WebSocket test ready</div>
        </div>
    </div>

    <script>
        let websocket = null;
        let isConnected = false;
        let canvas = document.getElementById('gameCanvas');
        let gameRenderer = null; // Will be initialized by Rust WASM
        let wasmModule = null;
        
        // Load WASM module
        async function loadWasm() {
            try {
                wasmModule = await import('/static/pkg/ttrpg_rust_core.js');
                await wasmModule.default();
                addLog('info', 'WASM module loaded successfully');
                return true;
            } catch (error) {
                addLog('error', `Failed to load WASM: ${error}`);
                return false;
            }
        }
        
        // Initialize canvas for WebGL
        async function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Load WASM first
            const wasmLoaded = await loadWasm();
            if (!wasmLoaded) {
                addLog('error', 'Cannot initialize renderer without WASM');
                return;
            }
            
            try {
                // Use the exported init function instead of constructor
                gameRenderer = wasmModule.init_game_renderer(canvas);
                startRenderLoop();
                addLog('info', 'WebGL renderer initialized');
            } catch (error) {
                addLog('error', `Failed to initialize WebGL: ${error}`);
            }
        }
        
        function startRenderLoop() {
            function render() {
                if (gameRenderer) {
                    try {
                        gameRenderer.render();
                    } catch (error) {
                        console.error('Render error:', error);
                    }
                }
                requestAnimationFrame(render);
            }
            render();
        }
        
        // WebSocket functions
        function updateStatus(status, text) {
            document.getElementById('statusDot').className = `status-dot status-${status}`;
            document.getElementById('statusText').textContent = text;
            
            const buttons = ['disconnectBtn', 'pingBtn', 'tableBtn', 'spriteBtn', 'testBtn'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = !isConnected;
            });
            document.getElementById('connectBtn').disabled = isConnected;
        }
        
        function addLog(type, message) {
            const log = document.getElementById('logArea');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${time}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        function connectWS() {
            try {
                addLog('info', 'Connecting...');
                updateStatus('connecting', 'Connecting...');
                
                websocket = new WebSocket('ws://127.0.0.1:12345/ws');
                
                websocket.onopen = () => {
                    isConnected = true;
                    updateStatus('connected', 'Connected');
                    addLog('info', 'Connected to WebSocket');
                };
                
                websocket.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    addLog('received', `${msg.type}: ${JSON.stringify(msg.data || {})}`);
                    
                    // Forward sprite data to Rust renderer
                    if (gameRenderer && msg.type === 'sprite_create' && msg.data) {
                        try {
                            addLog('info', `Attempting to add sprite: ${msg.data.name} with texture: ${msg.data.texture_path}`);
                            console.log('Full sprite data:', msg.data);
                            gameRenderer.add_sprite(msg.data);
                            addLog('info', `Successfully added sprite: ${msg.data.name}`);
                        } catch (error) {
                            addLog('error', `Failed to add sprite: ${error}`);
                            console.error('Sprite add error:', error, 'Data:', msg.data);
                        }
                    }
                };
                
                websocket.onclose = (event) => {
                    isConnected = false;
                    updateStatus('disconnected', 'Disconnected');
                    addLog('info', `Disconnected (${event.code})`);
                };
                
                websocket.onerror = () => {
                    isConnected = false;
                    updateStatus('disconnected', 'Error');
                    addLog('error', 'Connection error');
                };
                
            } catch (error) {
                addLog('error', `Error: ${error.message}`);
            }
        }
        
        function disconnectWS() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
        }
        
        function sendMessage(msg) {
            if (websocket && isConnected) {
                websocket.send(JSON.stringify(msg));
                addLog('sent', `${msg.type}`);
            }
        }
        
        function sendPing() {
            sendMessage({ type: 'ping', timestamp: Date.now() / 1000 });
        }
        
        function requestTable() {
            sendMessage({ type: 'table_request', timestamp: Date.now() / 1000 });
        }
        
        function createSprite() {
            const name = document.getElementById('spriteInput').value || 'Test Sprite';
            sendMessage({
                type: 'sprite_create',
                data: {
                    id: `sprite_${Date.now()}`,
                    name: name,
                    x: Math.random() * 400 + 100,
                    y: Math.random() * 300 + 100,
                    width: 40,
                    height: 40,
                    scale_x: 1.0,
                    scale_y: 1.0,
                    rotation: 0.0,
                    layer: 'tokens',
                    texture_path: name.toLowerCase().includes('hero') ? 'hero.png' : 
                                 name.toLowerCase().includes('enemy') ? 'enemy.png' : 
                                 name.toLowerCase().includes('chest') ? 'chest.png' : 
                                 name.toLowerCase().includes('goblin') ? 'enemy.png' : 
                                 name.toLowerCase().includes('treasure') ? 'chest.png' : '',
                    color: '#ffffff'
                }
            });
        }
        
        function createTestSprites() {
            const sprites = [
                { 
                    id: 'hero_1',
                    name: 'Hero', 
                    x: 100, 
                    y: 100, 
                    width: 40, 
                    height: 40,
                    scale_x: 1.0,
                    scale_y: 1.0,
                    rotation: 0.0,
                    layer: 'tokens',
                    texture_path: 'hero.png',
                    color: '#ffffff'
                },
                { 
                    id: 'enemy_1',
                    name: 'Goblin', 
                    x: 200, 
                    y: 150, 
                    width: 35, 
                    height: 35,
                    scale_x: 1.0,
                    scale_y: 1.0,
                    rotation: 0.0,
                    layer: 'tokens',
                    texture_path: 'enemy.png',
                    color: '#ffffff'
                },
                { 
                    id: 'chest_1',
                    name: 'Treasure', 
                    x: 300, 
                    y: 200, 
                    width: 30, 
                    height: 25,
                    scale_x: 1.0,
                    scale_y: 1.0,
                    rotation: 0.0,
                    layer: 'map',
                    texture_path: 'chest.png',
                    color: '#ffffff'
                }
            ];
            
            sprites.forEach((sprite, i) => {
                setTimeout(() => {
                    sendMessage({ type: 'sprite_create', data: sprite });
                }, i * 100);
            });
        }
        
        function getRandomColor() {
            const colors = ['#4ade80', '#3b82f6', '#ef4444', '#f59e0b', '#8b5cf6', '#06b6d4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - camera.x) * camera.zoom,
                y: (worldY - camera.y) * camera.zoom
            };
        }
        
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX / camera.zoom + camera.x,
                y: screenY / camera.zoom + camera.y
            };
        }
        
        function clearLog() {
            document.getElementById('logArea').innerHTML = '<div class="log-entry log-info">[Cleared] Log cleared</div>';
        }
        
        function toggleTestPanel() {
            const panel = document.getElementById('testPanel');
            const btn = document.getElementById('toggleBtn');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                btn.textContent = 'Hide Panel';
            } else {
                panel.style.display = 'none';
                btn.textContent = 'Show Panel';
            }
        }
        
        // Initialize
        window.addEventListener('load', () => {
            initCanvas();
            setTimeout(() => {
                loadDefaultTextures();
                setTimeout(connectWS, 1000); // Wait for textures to load
            }, 500);
        });
        
        window.addEventListener('resize', () => {
            if (gameRenderer) {
                gameRenderer.resize(window.innerWidth, window.innerHeight);
            }
        });
        
        function loadDefaultTextures() {
            // Load actual images from resources directory
            const textures = [
                { name: 'hero.png', path: '/resources/Hero.png' },
                { name: 'enemy.png', path: '/resources/goblin.png' },
                { name: 'chest.png', path: '/resources/treasure.png' },
                { name: 'player.png', path: '/resources/player1.png' },
                { name: 'token.png', path: '/resources/token_1.png' }
            ];
            
            textures.forEach(tex => {
                if (gameRenderer) {
                    addLog('info', `Starting to load texture: ${tex.name} from ${tex.path}`);
                    const img = new Image();
                    img.onload = () => {
                        try {
                            console.log(`Image loaded successfully: ${tex.name}, size: ${img.width}x${img.height}`);
                            gameRenderer.load_texture(tex.name, img);
                            addLog('info', `Successfully loaded texture: ${tex.name} (${img.width}x${img.height})`);
                        } catch (error) {
                            addLog('error', `Failed to load texture ${tex.name}: ${error}`);
                            console.error('Texture load error:', error);
                        }
                    };
                    img.onerror = (e) => {
                        addLog('error', `Failed to load image: ${tex.path}`);
                        console.error('Image load error:', e, 'Path:', tex.path);
                    };
                    img.src = tex.path;
                } else {
                    addLog('error', 'GameRenderer not available for texture loading');
                }
            });
        }
        
        // Canvas interaction - pass to Rust WebGL renderer
        canvas.addEventListener('mousedown', (e) => {
            if (gameRenderer) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                gameRenderer.handle_mouse_down(x, y);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (gameRenderer) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                gameRenderer.handle_mouse_move(x, y);
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (gameRenderer) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                gameRenderer.handle_mouse_up(x, y);
                addLog('info', `Canvas clicked at (${Math.floor(x)}, ${Math.floor(y)})`);
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            if (gameRenderer) {
                e.preventDefault();
                gameRenderer.handle_wheel(e.deltaY);
            }
        });
    </script>
</body>
</html>
